package top.dhc.mydb.backend.dm.page;

/**
 * Page 页面接口
 *
 * 设计核心：
 * Page 是数据库存储管理的基本单位，数据库文件被划分为固定大小的页面进行管理
 *
 * 在数据库系统中的位置：
 * 数据库文件被划分为固定大小的页面，DM层以页面为单位管理数据的读写，页面是缓冲池管理的基本单元，DataItem存储在Page中
 *
 * 关键设计理念：
 * 1. 缓存管理：通过 release 与缓存池配合，实现页面的缓存和驱逐
 * 2. 并发控制：通过 lock unlock 支持多线程安全访问
 * 3. 脏页管理：通过 dirty 标记哪些页面被修改需要写回磁盘
 * 4. 延迟写入：修改页面时只在内存中操作标记为脏，稍后批量写回磁盘
 *
 * 典型的页面生命周期：
 * 1. 从磁盘加载页面到内存
 * 2. lock 获取锁准备读写
 * 3. 读写 getData 返回的数据
 * 4. setDirty 如果修改了数据标记为脏页
 * 5. unlock 释放锁
 * 6. release 释放引用允许页面被驱逐
 * 7. 脏页在适当时机写回磁盘
 */
public interface Page {

    /**
     * 获取页面的锁
     *
     * 使用场景：
     * 在读取或修改页面数据之前调用，防止多个线程同时修改同一页面导致数据不一致
     *
     * 锁的粒度：
     * 这是页面级别的锁，比表级锁粒度更细，提高并发性能
     *
     * 典型使用模式：
     * page.lock();
     * try {
     *     修改页面数据
     * } finally {
     *     page.unlock();
     * }
     */
    void lock();

    /**
     * 释放页面的锁
     *
     * 注意事项：
     * 必须与 lock 成对使用，建议在 finally 块中调用确保锁一定会被释放
     */
    void unlock();

    /**
     * 释放对页面的引用
     *
     * 作用：
     * 通知 PageCache 不再使用此页面，减少页面的引用计数，当引用计数为0时页面可以被从缓存中驱逐
     *
     * 与 AbstractCache 的关系：
     * PageCache 继承自 AbstractCache 使用引用计数管理页面，release 会调用 AbstractCache.release
     *
     * 调用时机：
     * 当上层模块使用完页面后必须调用 release，否则页面会一直占用缓存可能导致内存泄漏
     *
     * 使用示例：
     * Page page = pageCache.getPage(pageNumber);
     * try {
     *     使用页面
     * } finally {
     *     page.release();
     * }
     */
    void release();

    /**
     * 设置页面的脏标记
     *
     * 参数 dirty：true 表示页面已被修改需要写回磁盘，false 表示页面未被修改可以直接丢弃
     *
     * 脏页的含义：
     * 脏页指内存中的页面数据与磁盘上的不一致需要写回，干净页指内存中的页面数据与磁盘上的一致可以直接丢弃
     *
     * 为什么需要脏页标记：
     * 1. 性能优化：修改时不立即写磁盘减少磁盘IO
     * 2. 批量写入：多次修改可以合并为一次写入
     * 3. 缓存驱逐：驱逐干净页不需要写磁盘，驱逐脏页需要先写回
     *
     * 调用时机：
     * 当修改页面数据后必须调用 setDirty(true)
     */
    void setDirty(boolean dirty);

    /**
     * 判断页面是否为脏页
     *
     * 返回值：true 表示页面已被修改，false 表示页面未被修改
     *
     * 使用场景：
     * 缓存驱逐时判断是否需要写回磁盘，检查点时找出所有脏页并写回，系统关闭时将所有脏页写回保证数据持久化
     */
    boolean isDirty();

    /**
     * 获取页面的页号
     *
     * 返回值：页号，从1开始编号，0通常保留作为特殊用途
     *
     * 页号的作用：
     * 1. 唯一标识每个页面
     * 2. 物理定位：页号乘以页面大小等于页面在文件中的偏移量
     * 3. 缓存键值：页号作为 PageCache 中的 key
     * 4. UID 组成：DataItem 的 UID 由页号和页内偏移组成
     */
    int getPageNumber();

    /**
     * 获取页面的原始字节数据
     *
     * 返回值：页面数据的字节数组，通常是固定大小如8KB
     *
     * 返回内容：
     * 返回的是页面的完整数据不是副本而是引用，直接修改返回的数组会影响页面内容，修改后必须调用 setDirty(true) 标记为脏页
     *
     * 页面数据的结构：
     * 页面中可能包含多个 DataItem 以及页面元数据：[PageMetadata] [DataItem1] [DataItem2] ... [FreeSpace]
     *
     * 使用注意事项：
     * 1. 修改前必须先 lock
     * 2. 修改后必须 setDirty(true)
     * 3. 使用完必须 unlock
     * 4. 不要长时间持有数据引用可能导致并发问题
     */
    byte[] getData();
}